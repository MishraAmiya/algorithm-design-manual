---
layout: post
title: 3.3 Dictionaries
---

* the dictionary abstract data type permits access to data items by content
* items added to a dictionary can be found by their key

## Dictionary operations

* search - given a search key, return a pointer to the element whose key value is k (if one exists)
* insert - given an element and it's key add it to the dictionary
* delete - given an element remove it form the dictionary
* max, min - certain implementations support efficient retrieval of the largest/smallest key from the dictionary
* predecessor, successor - certain implementations support efficient retrieval of the item immediately before/after a given key (in sorted order) from the dictionary
* different implementations provide better/worse running time guarantees for different operations

## Dictionary implementations

In practice dictionaries are implemented with binary search trees or hashtables but it's interesting to have a look at how we would implement them using array or linked lists. 

### unsorted arrays

* search - O(n) - checking the key against each element (potentionally)
* insert - O(1) - just add the element at the end
* delete - O(1) - pointer is given to element to remove, overwrite position with last element
* min/max - O(n) - requires linear sweep through the elements
* predecessor/successor - O(n) - requires linear sweep through the elements

### sorted arrays

* search - O(log n) - using binary search
* insert - O(n) - because making room for the new item
* delete - O(n) - because filling the hole left by the deletem item
* min/max - O(1) - first and last element
* predecessor/successor - O(1) - elements in previous/next positions

### linked lists

A linked list can be singly or doubly linked and sorted or unsorted. This has effects on the running time of the various dictionary operations. 

* search - have to sweep through all elements in all cases
* insert - items can simply be added at the en of the unsorted list but have to find their place in the sorted list
* delete - we have to find the element before the element to delete to update to pointers, double linked list are useful here but has to do a linear sweep for singly linked
* successor is straightforward in sorted lists
* finding the precedessor is only easy in doubly linked sorted lists
* minimum - sits at the head of the sorted lists
* maximum - maintaining a pointer to the last element (tail) of the sorted lists makes this easy
     * on insertion check if we inserted in the last position (last->next still null)
     * on delete in doubly linked lists if deleting last update the tail pointer to its precedessor
     * delete in singly lists is already linear so adding an extra linear sweep to update the tail pointer doesn't do any harm
    
The table below lists the runtime complexity for each operation with different implementations:
 
* singly (1) or double (2) linked
* sorted (S) or unsorted (U)


| operation  |&nbsp;1,U&nbsp;|&nbsp;2,U&nbsp;|&nbsp;1,S&nbsp;|&nbsp;2,S&nbsp;
|:-----------|:-------------:|:-------------:|:-------------:|:-------------:
| search     | O(n)          | O(n)          | O(n)          | O(n)          
| insert     | O(1)          | O(1)          | O(n)          | O(n)         
| delete     | O(n)          | O(1)          | O(n)          | O(1)           
| successor  | O(n)          | O(n)          | O(1)          | O(1)           
| precedessor| O(n)          | O(n)          | O(n)          | O(1)          
| minimum    | O(n)          | O(n)          | O(1)          | O(1)          
| maximum    | O(n)          | O(n)          | O(1)          | O(1)



